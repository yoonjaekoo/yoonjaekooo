<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ëë§ì‡ê¸° ê²Œì„ (CSV, 1ì¸ í”Œë ˆì´)</title>
    <style>
        body { font-family: 'SF Pro Display', sans-serif; padding: 20px; background-color: #f8f8f8; }
        input { padding: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: 16px; }
        button { margin-left: 5px; padding: 8px 14px; border-radius: 8px; border: none; background: #007aff; color: white; font-size: 15px; cursor: pointer; transition: background 0.3s; }
        button:hover { background: #005ecf; }
        #log { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: auto; background: white; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
        #currentWord { font-weight: bold; font-size: 1.4em; color: #007aff; transition: color 0.3s, transform 0.3s; }
        .fade-in-up {
            animation: fadeInUp 0.4s ease both;
        }
        @keyframes fadeInUp {
            0% { opacity: 0; transform: translateY(10px); }
            100% { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

<h1>ëë§ì‡ê¸° ê²Œì„ (CSV, 1ì¸ í”Œë ˆì´)</h1>

<div>
    <p>í˜„ì¬ ë‹¨ì–´: <span id="currentWord"></span></p>
</div>

<input type="text" id="wordInput" placeholder="ë‹¨ì–´ ì…ë ¥">
<button onclick="submitWord()">ì œì¶œ</button>
<button onclick="resetGame()" style="background:#ff3b30;">ê²Œì„ ì´ˆê¸°í™”</button>

<h3>ê²Œì„ ë¡œê·¸</h3>
<div id="log"></div>

<script>
    let currentWord = "";
    let usedWords = [];
    let allWords = [];

    // CSV ì½ê¸° (ëª…ì‚¬ë§Œ)
    fetch("kr_korean.csv")
        .then(res => res.text())
        .then(text => {
            const lines = text.split("\n");
            for(let i=1;i<lines.length;i++){
                const row = lines[i].split(",");
                const word = row[0]?.trim().replace(/-/g, "");
                const pos = row[1]?.trim();
                if(word && pos === "ëª…ì‚¬") allWords.push(word);
            }
            logMessage("ë‹¨ì–´ ë¦¬ìŠ¤íŠ¸ ë¡œë“œ ì™„ë£Œ! ëª…ì‚¬ ì´ ë‹¨ì–´: " + allWords.length);
        })
        .catch(err => logMessage("ë‹¨ì–´ ë¦¬ìŠ¤íŠ¸ ë¡œë“œ ì‹¤íŒ¨: " + err));

    function getDuumEquivalent(char) {
        if(['ë¼','ë˜','ë¡œ','ë¢°','ë£¨','ë¥´'].includes(char)) return String.fromCharCode(char.charCodeAt(0)-1024);
        if(['ë´','ë ¤','ë¡€','ë£Œ','ë¥˜'].includes(char)) return String.fromCharCode(char.charCodeAt(0)-512);
        if(char=='ë¦¬') return 'ì´';
        if(['ë‚˜','ë‚´','ë…¸','ë‡Œ','ëˆ„','ëŠ'].includes(char)) return String.fromCharCode(char.charCodeAt(0)+1024);
        if(['ëƒ','ë…€','ë…œ','ë‡¨','ë‰´'].includes(char)) return String.fromCharCode(char.charCodeAt(0)+512);
        if(char=='ë‹ˆ') return 'ì´';
        return null;
    }

    function checkChain(lastChar, firstChar){
        const duum = getDuumEquivalent(lastChar);
        return firstChar === lastChar || (duum && firstChar === duum);
    }

    function compTurn(){
        if(!currentWord) return;
        let lastChar = currentWord.slice(-1);
        let candidates = allWords.filter(w =>
            !usedWords.includes(w) && checkChain(lastChar, w[0])
        );
        if(candidates.length === 0){
            logMessage("ğŸ’» ì»´í“¨í„°ê°€ ìœ íš¨í•œ ë‹¨ì–´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤! ê²Œì„ ì¢…ë£Œ!");
            return;
        }
        let choice = candidates[Math.floor(Math.random()*candidates.length)];
        usedWords.push(choice);
        currentWord = choice;
        updateCurrentWord(choice);
        logMessage("ğŸ’» ì»´í“¨í„°: " + choice, true);
    }

    function submitWord(){
        let input = document.getElementById("wordInput");
        let word = input.value.trim().replace(/-/g,"");
        input.value = "";
        if(!word) return;

        if(currentWord && !checkChain(currentWord.slice(-1), word[0])){
            logMessage(`âŒ ëë§ì´ í‹€ë ¸ìŠµë‹ˆë‹¤! '${word}'ëŠ” '${currentWord.slice(-1)}' ë˜ëŠ” ë‘ìŒë²•ì¹™ ì ìš© ê¸€ìë¡œ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤.`);
            return;
        }
        if(usedWords.includes(word)){
            logMessage("âš ï¸ " + word + " ì´ë¯¸ ì‚¬ìš©ë¨!");
            return;
        }
        if(!allWords.includes(word)){
            logMessage("âŒ " + word + " ìœ íš¨í•˜ì§€ ì•Šì€ ë‹¨ì–´!");
            return;
        }

        usedWords.push(word);
        currentWord = word;
        updateCurrentWord(word);
        logMessage("ğŸ™‹ ì‚¬ìš©ì: " + word, true);

        setTimeout(compTurn, 500);
    }

    function resetGame(){
        currentWord = "";
        usedWords = [];
        document.getElementById("log").innerHTML = "";
        document.getElementById("currentWord").innerText = "";
    }

    function logMessage(msg, animated=false){
        const log = document.getElementById("log");
        let entry = document.createElement("div");
        entry.innerHTML = msg;
        if(animated) entry.classList.add("fade-in-up");
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;
    }

    function updateCurrentWord(word){
        let cw = document.getElementById("currentWord");
        cw.innerText = word;
        cw.style.color = "#34c759"; // ì• í”Œ ê·¸ë¦°
        cw.style.transform = "scale(1.2)";
        setTimeout(() => {
            cw.style.color = "#007aff";
            cw.style.transform = "scale(1)";
        }, 300);
    }
</script>

</body>
</html>
